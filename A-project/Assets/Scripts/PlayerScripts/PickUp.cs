// Этот скрипт вешаем на Charecter basis он будет уничтожать предмет и ложить информацию о нём в выбраную им же ячейку в инвентаре. // Также если инвентарь полон и в него пытаються положить ещё этот скрипт отрисовывает на экране надпись "Инвентарь полон". // Сделать чтобы такие объекты как гриб складировались по много штук (На самом деле у нас будет в ячейке также лишь один гриб) Просто мы прибавим // Для ячеёки ещё одну переменную которая отражает количество элементов максимальное значение которой равно переменной в скрипте этого гриба // Как только количество грибов в ячейке равно или больше этого числа грибы начинают ложиться в следующуу ячейку // В будующем сделать чтобы для категорий были не массивы а списки тогда она будут сами реорганизовываться при удалении элемента из инвентаря // А ещё позже чтобы при открытии раздела инвентаря всё чтобы игра не тормозила тоже сделать этот раздел списком и вместо того чтобы заполнять // этот раздел при его открытии мы как нибудь должны будем просматривать все ячейки на предмет категории на пример оружия потом идёт броняъ // и если мы только что добавили броню значит и в список всё при подбирании объекта мы будем добавлять его в список всё. А при удалении из  // какой нибуть категории будем искать в категории всё объект с такими же параметрами и удалять его оттуда тоже. // В этом скрипте я использовал метафоры чтобы лучше понимать процесс который тут происходит Место на"Складе" это номера массивов с информацией // об объектах, очередь с людьми у которых есть купоны это список с переменными int, ну и ячейки в инвентаре это ячейки в инвентаре :-) using UnityEngine;  public class PickUp : MonoBehaviour  { 	public Inventory Inv;			// Сдесь лежит скрипт Инвентраь 	public ObjectRegisrator OR;		// Сдесь лежит CharecterBasis пустышка на которой вести скрипт ObjectRegistrator 	ObjectData OD;                  // Сдесь находиться скрипт ObjectData того объекта с которым мы в данный момент работаем     StoreObjectData SOD;            // Это объект для хранения данных на складе 	int time = 0;					// Эта переменная указывает сколько времени будет показываться окошко "Инвентарь пуст" 	 	// !!!!!!!!!!!!!!! Нужно сделать чтобы когда мы подбираем объект то ячейка категории всё где будет находиться наш объект должна стать 	// выбранной а также ячейка той категории которой был выбран наш объект тоже должна стать выбранной где лежит объект 	 	void Update() 	{ 		// Если нажата левая кнопка мыши и инвентарь выключен и в скрипте ObjectRegistrator переменная FocusObject не равана нулю 		if(Input.GetMouseButtonDown(0) & Inv.InventoryOn == false & OR.FocusObject != null)		 		{ 			if(Inv.EngagedSlots < 40)	    // Если максимальное количество слотов не достигнуто 			{ 				PickUpObject();			    // Вызываем метод подбирания объекта                 Inv.InventoryDrawn = false; // Specify that updating inventory rendering is required             } 			else 						    // Иначе если максимальное количество слотов достигнуто 			{ 				time = 100;				    // Ставим счётчик времени time на 100; 			} 		} 		if(time > 0)	// Если переменная time больше ноля 			time --;	// То отнимаем у неё еденицу 	}  	 	void PickUpObject() 	{         OD = OR.FocusObject.GetComponent<ObjectData>();     // We put the script of the stored object into the variable "OD"         SOD = new StoreObjectData();          // Copy all the data from the selected object into it.         SOD.WorldOffsetUp = OD.WorldOffsetUp;         SOD.LocalOffsetZ = OD.LocalOffsetZ;         SOD.LocalOffsetX = OD.LocalOffsetX;         SOD.ObjectName = OD.ObjectName;         SOD.Description = OD.Description;         SOD.ObjectTexture = OD.ObjectTexture;         SOD.ObjectType = OD.ObjectType;         SOD.Queue = OD.Queue;         SOD.Path = OD.Path;         SOD.StackbleObject = OD.StackbleObject;         SOD.StackCount = OD.StackCount;         SOD.DestroyableObject = OD.DestroyableObject;         SOD.StateObject = OD.StateObject;          FindASuitablePlace();							// Вызываем метод FindASuitablePlace 		Destroy(OR.FocusObject);                        // Удаляем объект в фокусе
        Inv.InventoryDrawn = false;     // We indicate that visually the inventory needs to be updated
        Debug.Log("Обновляем инвентарь");
    }   	// Этот метод находит подходящее место в "Очереди" и вставляет туда объект 	void FindASuitablePlace()	 	{ 		int PlaceInLine	= 0;			// Вычисляем куда поставить "Нового человека" в очереди  		if(OD.StackbleObject == true)   // Если объект в фокусе стакуемый то мы стараемся найти ячейку с таким же объектом и прибавить к ней +1 		{
            Debug.Log("Этот объект стакуемый");
            // Проводим итерацию по очереди людей с 0 до конца, спрашиваем у каждого талон, идём по нему на склад и там смотрим на тип и номер
            if(Inv.Coupons.Count > 0 && Inv.Coupons.Count < 40)     // Если в очереди уже есть купоны
            { 
                for (byte a = 0; a < Inv.Coupons.Count; a++)        // Продолжаем цикл пока не переберём всех купонов в очереди
                {
                    Debug.Log("Очередной цикл");                     if (OD.ObjectType == Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].ObjectType) // Если тип объекта в фокусе равен типу объекта "человека в очереди" 				    {                         Debug.Log("Тип объекта равен типу объекта в очереди"); 					    // Если Queue объекта в фокусе равен Queue "человека в очереди" то есть мы нашли точно такой же объект                         if(OD.Queue == Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].Queue)  					    {                             Debug.Log("Мы нашли точно такой же объект"); 						    // И если у объекта в фокусе макс. число стака больше чем лежит в ячейке на складе того "Человека"                             if(OD.StackCount > Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].StackValue) 						    {                                 Debug.Log("В эту ячейку на складе может влезть ещё один такой же объект");                                 Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].StackValue++;                  // То мы плюсуем к переменной отвечающей за количество предметов в ячейке 							    break; // И прерываем цикл 						    }                             else // Otherwise, if this cell is already filled with this kind of objects
                            {
                                Debug.Log("Ложим гриб в следующую ячейку на складе");
                                InsertNewCoupon(PlaceInLine);                                   // Вызываем метод "Вставить нового купона"                                 Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].StackValue++;      // Плюсуем к переменной отвечающей за количество предметов в ячейке 						        break;  // И прерываем цикл
                            } 					    }                         // Иначе если Queue объекта в фокусе меньше Queue "человека в очереди" то есть мы наткнулись на объект старше по очереди                         else if (OD.Queue < Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].Queue) 					    { 						    InsertNewCoupon(PlaceInLine);                                   // Вызываем метод "Вставить нового купона"                             Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].StackValue++;      // Плюсуем к переменной отвечающей за количество предметов в ячейке 						    break;  // И прерываем цикл 					    } 				    }                     else if (OD.ObjectType < Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].ObjectType) 				    { 					    InsertNewCoupon(PlaceInLine); // Вызываем метод "Вставить нового купона"                         Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].StackValue ++; // То мы плюсуем к переменной отвечающей за количество предметов в ячейке 					    break;      // И прерываем цикл 				    } 				    PlaceInLine++;  // Прибавляем к PlaceInLine чтобы в следующем цикле опрашивать следующего человека в очереди
                }             } 			else if(Inv.Coupons.Count == 0)         // Иначе если это первый талон и талонов ещё нет 			{           //      Debug.Log("Это первый талон других талонов ещё нет"); 				InsertNewCoupon(0);                 // Вызываем метод "Вставить нового купона"                 Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].StackValue ++; // То мы плюсуем к переменной отвечающей за количество предметов в ячейке 			}             else if(Inv.Coupons.Count == 40)        // Иначе если инвентарь полон
            {
                Debug.LogError("Инвентарь полон");
            }         //     Debug.Log("Количество купонов " + Inv.Coupons.Count);
        } 		else if(OD.StackbleObject == false) // Иначе если объект в фокусе нестакуемый то мы ищем свободное место  		{
            Debug.Log("Объект в фокусе нестакуемый");
            // Проводим итерацию по очереди людей с 0 до конца, спрашиваем у каждого талон, идём по нему на склад и там смотрим на тип и номер

            if (Inv.Coupons.Count > 0 && Inv.Coupons.Count < 40)     // Если в очереди уже есть купоны
            {
                for (byte a = 0; a < Inv.Coupons.Count; a++)        // Продолжаем цикл пока не переберём всех купонов в очереди
                {
                    if (OD.ObjectType == Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].ObjectType) // Если тип объекта в фокусе равен типу объекта "человека в очереди"
                    {
                        if (OD.Queue < Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].Queue)   // Если Queue объекта в фокусе меньше Queue "человека в очереди"
                        {
                            Debug.Log("Мы подобрали тот же тип объекта, номер подбираемого объекта в очереди меньше того что на складе");
                            InsertNewCoupon(a);                                 // Вызываем метод "Вставить нового купона"
                            break; // То прерываем цикл
                        }
                    }
                    else if (OD.ObjectType < Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].ObjectType)  // Если тип объекта в фокусе меньше типа объекта "человека в очереди"
                    {
                        Debug.Log("Типы объектов разные, Тип подбираемого объекта младше чем тип объекта в инвентаре");
                        Debug.Log("Тип подбираемого объекта равен " + OD.ObjectType);
                        Debug.Log("Тип объекта в инвентаре равен " + Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].ObjectType);
                        Debug.Log("Номер цикла и номер места купона в которое мы хотим вставить его в очереди " + a);

                        InsertNewCoupon(a);                               // Вызываем метод "Вставить нового купона"
                        break; // То прерываем цикл
                    }
                    else if (OD.ObjectType > Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].ObjectType) // Если тип объекта в фокусе меньше типа объекта "человека в очереди"
                    {

                    }

                    PlaceInLine++; // Прибавляем к PlaceInLine чтобы в следующем цикле опрашивать следующего человека в очереди
                }
            }             else if(Inv.Coupons.Count == 0)         // Иначе если это первый талон и талонов ещё нет 			{ 				InsertNewCoupon(0);                 // Вызываем метод "Вставить нового купона" 			}             else if(Inv.Coupons.Count == 40)        // Иначе если инвентарь полон
            {
                Debug.LogError("Инвентарь полон");
            }             Debug.Log("Выбран номер в очереди купонов: " + PlaceInLine);              //  //			InsertNewCoupon(PlaceInLine);                               // Вызываем метод "Вставить нового купона" //            Inv.ObjectsInStore[Inv.Coupons[PlaceInLine]].StackCount++;  // И мы плюсуем к переменной отвечающей за количество предметов в ячейке 		} 	}   	// Этот метод вставляет нового человека в вычесленное место в очереди и присваевает ему место на складе куда и ложит все его данные 	void InsertNewCoupon(int PlaceInLine) 	{ 		int WarehousePlace = FindAndfillWarPlace();		                // Вызываем метод FindWarehousePlace и присваиваем переменной WarehousePlace EmptyPlace 		Inv.Coupons.Insert(PlaceInLine, WarehousePlace); 	            // Вставляем в очередь нового человека с номером места на "Складе"         CategoryChanged(Inv.ObjectsInStore[WarehousePlace].ObjectType); // Вызываем метод CategoryChanged и передаём ему тип подобранного объекта 		Inv.EngagedSlots ++;								            // Прибавляем к количеству занятых слотов +1 	} 	  	// "FindAndfillWarehousePlace" Найти и заполнить. Этот метод ищет по именам объектов в массиве NamesObject первое пусто место на "Складе", 	// помещает туда всю информацию об объекте и возвращает в переменную WarehousePlace номер этого места на складе 	int FindAndfillWarPlace() 	{ 		int EmptyPlace = 0; // Эта переменная символизирует пустое место на складе          for (int a = 0; Inv.ObjectsInStore[EmptyPlace] != null ; a++) // Закончим итерацию когда наткнёмся на пустое имя на "Складе"         {             EmptyPlace++;         }          Inv.ObjectsInStore[EmptyPlace] = SOD;           // Ложим на пустое место на "Складе" копию подобранного объекта 		return EmptyPlace;							    // Возвращаем пустое место 	}   	// Этот метод опрашивает категорию подобранного предмета и сообщает какая категория инвентаря была изменена чтобы обновить её при открытии 	void CategoryChanged(Type Types) 	{ 		Inv.InvChanged = true;					// Изменяем значение переменной "Инвентарь был изменён" на значение правда 		if(OD.ObjectType == Type.Weapon)		// Если тип объекта "Оружие" 			Inv.WeapChanged = true;				// То делаем переменную WeapChanged равной правда 		if(OD.ObjectType == Type.Armor)			// Если тип объекта "Броня" 			Inv.ArmorChanged = true;			// То делаем переменную ArmorChanged равной правда 		if(OD.ObjectType == Type.Food)			// Если тип объекта "Еда" 			Inv.FoodChanged = true;				// То делаем переменную FoodChanged равной правда 		if(OD.ObjectType == Type.Magic)			// Если тип объекта "Магия" 			Inv.MagicChanged = true;			// То делаем переменную MagicChanged равной правда 		if(OD.ObjectType == Type.Construction)	// Если тип объекта "Строительство" 			Inv.ConsChanged = true;				// То делаем переменную ConsChanged равной правда 		if(OD.ObjectType == Type.Other)			// Если тип объекта "Разное" 			Inv.OtherChanged = true;			// То делаем переменную OtherChanged равной правда 	}  	// Этот метот OnGUI в этом скрипте занимаеться только тем что отрисовывает текст "Инвентарь полон" когда TextTrue равна правда 	void OnGUI() 	{ 		if(time >0)	// Пока переменная time больше ноля показываем надпись что инвентарь полон 			GUI.Label(new Rect(590, 10, 200, 200), "Инвентарь полон"); 	} } 