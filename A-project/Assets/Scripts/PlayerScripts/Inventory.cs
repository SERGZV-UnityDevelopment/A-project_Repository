// Этот скрипт вешаеться на CharecterBasis и выполняет роль отрисовки инвентаря игрока using UnityEngine; using System.Collections.Generic;  //int ListSlot = 0;				// Номер слота в списке //List<string> NamesAllObject;	// Имена всех объектов //List<string> DescrAllObject;	// Описания всех объектов //List<Texture> TextureAllObj;	// Текстуры всех объектов  //!!!!!!! Когда сделаю выкидывание объектов нужно сделать чтобы переменная EngagedSlots в этом скрипте уменьшалась чтобы мы правильно сегнали // зировали когда нужно высвечивать окошко что инвентарь полон а когда ненужно  public class Inventory : MonoBehaviour {     public Texture2D line, Backline;        // Текстура полоски состояния предметов в инвентаре и фоновая полоска     public Color[] colors = new Color[1];   // Массив цветов обязательный для этой линии состоящий всего из одного цвета     Color[] colorsback = new Color[1];      // Массив цветов обязательный для этой линии состоящий всего из одного цвета     const int AS = 40;                      // Amount SlotsМаксимальное количество слотов в инвентаре     public ObjectRegisrator OR;             // Сдесь лежит скрипт ObjectRegistrator     public PlayerController PC;             // Сдесь лежит скрипт PlayerController     public PlayerCamera PlCam;              // Сдесь лежит скрипт PlayerCamera     public bool InventoryOn = false;        // включен ли инвентарь, true говорит о том что включен     public int EngagedSlots = 0;            // Количество занятых слотов нужно чтобы не дать ложить предметы если макс кол достигнуто     public bool InvChanged = false;         // "InventoryChanged" Было ли изменено содержимое инвентаря     public bool WeapChanged = false;        // "WeaponChenged" Была ли изменена категория "Оружие"     public bool ArmorChanged = false;       // Была ли изменена категория "Защита"     public bool FoodChanged = false;        // Была ли изменена категория "Еда"     public bool MagicChanged = false;       // Была ли изменена категория "Магия"     public bool ConsChanged = false;        // "ConstructionChanged" Была ли изменена категория с "Строительство"     public bool OtherChanged = false;       // Была ли изменена категория с "Разное"     public Transform CharacterBasis;        // Сдесь лежит трансформация пустышки игрока CharacterBasis     public GUIStyle ToolBarStyle;           // Стиль кнопок для категорий предметов     public GUIStyle NameDescrObjStyle;      // Стиль имени объекта в описании предмета     public GUIStyle DescriptionStyle;       // Стиль окна описания предметов     public GUIStyle CellStyle;              // Стиль ячеек в инвентаре     public GUIStyle UpperCellStyle;         // Стиль для текста в ячейках инвентаря отображающего количество объектов или их состояние     public Rect[] UpperCells = new Rect[AS];// Это массив с координатами ячеек инвентаря с информацией которые лягут поверх обычных ячеек     bool WasLocked = true;                  // Был ли заблокирован курсор       // Категории - Всё, Оружие, Защита, Еда и зелья, Магия, Строительство, Прочее.. Инструменты(Tool) храняться в прочем.     public Texture[] CategoriesImage;       // Изображения для категорий     int ToolBarInt = 0;                     // Номер категори который сейчас выбран      // "Талоны" Я назвал этот список так потому что номера в этом списке похожи на людей в очереди с талонами У каждого человека есть "талон"     // Номер с описаниями именами и прочем Какбы талон на получение контенера с вещами на складе, а номер этого человека в очереди соответствует     // номер текстуры в категории всё     public List<int> Coupons;                                   // Объявляем список "Талоны"                                                                 //-----------------------------------------------------------------------------------------------------------------------------------------------     public string[] NamesObjects = new string[AS];              // Имена всех объектов на "Cкладе" информации     public string[] DescriptionsObjects = new string[AS];       // Описание всех объектов на "Cкладе" информации     public Texture[] TexturesObjects = new Texture[AS];         // Текстуры всех объектов на "Cкладе"     public Type[] TypesObjects = new Type[AS];                  // Типы всех объектов на "Складе"     public int[] QueueObject = new int[AS];                     // Номер объекта по которому он ставиться в очереди     public string[] PathsObjects = new string[AS];              // Пути всех обектов на "Складе"     public int[] StackValue = new int[AS];                      // В этом массиве храняться значения -(Сколько объектов в ячейке на "Складе")     public bool[] Destroyable = new bool[AS];                   // Массив состояний объектов на "Складе" (Разрушаемый не разрушаемый)     public float[] State = new float[AS];                       // Массив состояний насколько сломан объект на "Складе" (Новый или сломанный)                                                                 //-----------------------------------------------------------------------------------------------------------------------------------------------     public int AllNumber = 0;                                   // Номер выбраной ячейки в категории "Всё"     public Texture[] AllTextures = new Texture[AS];             // Текстуры всех объектов в категории "Всё"      public int WeaponNumber = 0;                                // Номер выбраной ячейки в категории "Оружие"     public Texture[] TexturesWeapon = new Texture[AS];          // Текстуры всего оружия в категории "Оружие"      public int ArmorNumber = 0;                                 // Номер выбраной ячейки в категории "Броня"     public Texture[] TexturesArmor = new Texture[AS];           // Текстуры всей брони в категории "Броня"      public int FoodNumer = 0;                                   // Номер выбраной ячейки в категории "Еда"     public Texture[] TexturesFood = new Texture[AS];            // Текстуры всей еды в категории "Еда"      public int MagicNumer = 0;                                  // Номер выбраной ячейки в категории "Магия"     public Texture[] TexturesMagic = new Texture[AS];           // Текстуры всей магии в категории "Магия"      public int ConstructionNumber = 0;                          // Номер выбраной ячейки в категории "Конструкция"     public Texture[] TexturesConstruction = new Texture[AS];    // Текстуры всех конструкций в категории "Конструкция"      public int OtherNumber = 0;                                 // Номер выбраной ячейки в категории "Разное"     public Texture[] TexturesOther = new Texture[AS];           // Текстуры всего разного в категории "Разное"        void Start()     {         Screen.lockCursor = true;           // Блокируем курсор         CalculatePosition.GeneratePosition(935, 115, 64, 64, UpperCells, 5);         colorsback[0] = Color.black;        // Задаём переменной цвета colorsback чёрный цвет, это будет цвет фона для полоски здоровья предмета         line = new Texture2D(1, 1);         // Создаём текстуру полоски здоровья предмета и помещаем её в переменную line         Backline = new Texture2D(1, 1);     // Создаём текстуру фона полоски здоровья предмета и помещаем её в переменную Backline         Backline.SetPixels(colorsback);     // Заполняем текстуру фона полоски здоровья предмета чёрным         Backline.Apply();                   // Применяем изменения цвета фона     }       void Update()     {         if (Input.GetKeyDown(KeyCode.Tab)) // Если нажата кнопка Таб и выключен инвентарь             InventoryOn = InventoryOn == false ? InventoryOn = true : InventoryOn = false; // Включен если выключен, и выключен если включен          if (!InventoryOn & WasLocked == false)   // Если инвентарь выключен и переменная "Курсор был заблокирован" ложь         {             OR.enabled = true;                   // Включаем скрипт регестрации объектов             Screen.lockCursor = true;            // Блокируем курсор             WasLocked = true;                    // И ставим значение переменной "Курсор был заблокирован" правда         }         else if (InventoryOn & WasLocked == true) // Если инвентарь включен и переменная "Курсор был заблокирован" правда         {             OR.enabled = false;                  // То мы выключаем скрипт регестрирования объектов             Screen.lockCursor = false;           // Разблокируем курсор             WasLocked = false;                   // И ставим значение переменной "Курсор был заблокирован" ложь         }     }       // Отрисовываем общий инвентарь если он включен     void OnGUI()     {         if (InventoryOn)                        // Если инвентарь включен         {             GUI.Box(new Rect(870, 60, 400, 580), "");           // Рисуем коробку размером с область инвентаря             GUI.Box(new Rect(930, 110, 330, 522), "");          // Создаём коробку в виде заднего фона             ToolBarInt = GUI.Toolbar(new Rect(930, 70, 330, 40), ToolBarInt, CategoriesImage, ToolBarStyle);    // Рисуем категории предметов              if (GUI.Button(new Rect(970, 640, 150, 30), "Use")) // Рисуем кнопку "Использовать объект" и если она нажата...                 UseObject(); // Вызываем метод использовать объект              if (GUI.Button(new Rect(1120, 640, 150, 30), "Drop")) // Рисуем кнопку "Бросить объект" и если она нажата...                 DropObject(); // Вызываем метод "Бросить объект"               switch (ToolBarInt)             {                 case 0:                     if (InvChanged) // Если Менялось содержимое инвентаря                         FillCategoryAll();  // То вызываем метод FillCategoryAll                     AllNumber = DrawCategoryAll(AllNumber, AllTextures); // Вызываем метод DrawInventory (Отрисовка категории "Всё")                     InvChanged = false;  // И говорим что инвентарь больше не изменялься                     break;                 case 1:                     if (WeapChanged)    // Если содержимое категории "Оружие" было изменено                         FillCategory(TexturesWeapon, Type.Weapon);  // Вызываем метод FillCategory                     WeaponNumber = DrawCategory(WeaponNumber, TexturesWeapon, Type.Weapon); // Вызываем метод DrawCategoty (Отрисовка категории)                     WeapChanged = false; // И говорим что категория "Оружие" больше не изменялась                     break;                 case 2:                     if (ArmorChanged)   // Если содержимое категории "Броня" было изменено                         FillCategory(TexturesArmor, Type.Armor);  // Вызываем метод FillCategory                     ArmorNumber = DrawCategory(ArmorNumber, TexturesArmor, Type.Armor); // Вызываем метод DrawCategoty (Отрисовка категории)                     ArmorChanged = false; // И говорим что категория "Броня" больше не изменялась                     break;                 case 3:                     if (FoodChanged) // Если содержимое категории "Еда" было изменено                         FillCategory(TexturesFood, Type.Food);  // Вызываем метод FillCategory                     FoodNumer = DrawCategory(FoodNumer, TexturesFood, Type.Food); // Вызываем метод DrawCategoty (Отрисовка категории)                     FoodChanged = false; // И говорим что категория "Еда" больше не изменялась                     break;                 case 4:                     if (MagicChanged) // Если содержимое категории "Магия" было изменено                         FillCategory(TexturesMagic, Type.Magic);  // Вызываем метод FillCategory                     MagicNumer = DrawCategory(MagicNumer, TexturesMagic, Type.Magic); // Вызываем метод DrawCategoty (Отрисовка категории)                     MagicChanged = false; // И говорим что категория "Магия" больше не изменялась                     break;                 case 5:                     if (ConsChanged) // Если категория "Строительство" была изменена                         FillCategory(TexturesConstruction, Type.Construction);  // Вызываем метод FillCategory                     ConstructionNumber = DrawCategory(ConstructionNumber, TexturesConstruction, Type.Construction); // Вызываем метод DrawCategoty                     ConsChanged = false; // И говорим что категория "ConstructionChanged" больше не изменялась                     break;                 case 6:                     if (OtherChanged) // Если категория "Разное" была изменена                         FillCategory(TexturesOther, Type.Other);  // Вызываем метод FillCategory                     OtherNumber = DrawCategory(OtherNumber, TexturesOther, Type.Other); // Вызываем метод DrawCategoty (Отрисовка категории)                     OtherChanged = false; // И говорим что категория "OtherChanged" больше не изменялась                     break;             }         }     }       // Объявляем метод DrawInventory он занимаеться отрисовкой инвентаря в категории "Всё"     int DrawCategoryAll(int number, Texture[] textures)     {         number = GUI.SelectionGrid(new Rect(935, 115, 320, 512), number, textures, 5, CellStyle);               // Рисуем слоты инвентаря                                                                                                                 // Рисуем "Коробки" с цифрами или состоянием предметов для слотов инвентаря         for (int i = 0; Coupons[i] != -1; i++) // Продолжаем цикл до тех пор пока номер купона не равен -1         {             if (StackValue[Coupons[i]] > 1) // Если значение количества предметов в ячейке на складе больше одного                 GUI.Box(UpperCells[i], "" + StackValue[Coupons[i]], UpperCellStyle); // То отрисовываем количество предметов в ячейке                                                                                      // Если объект в ячейке на "Складе" разрушаемый а его значение целостности больше 0% и менее 100%             if (Destroyable[Coupons[i]] == true & State[Coupons[i]] > 0 & State[Coupons[i]] < 100)             {   // То мы отрисовываем полоску состояния предмета для этой ячейки                 colors[0] = Color.Lerp(Color.red, Color.green, State[Coupons[i]] / 100); // сначала определяем цвет                 line.SetPixels(colors); // присваиваем этот цвет полоске которую мы отрисуем в этом цикле, в этой ячейке                 line.Apply();           // Сохраняем изменение цвета текстуры полоски                                         // Отрисовываем жизни предмета и задниф фон жизней                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50, 3), Backline);                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50 * State[Coupons[i]] / 100, 3), line);                 if (i == AS - 1) break; // Если номер цикла стал равен количеству ячеек -1 то прекращаем цикл             }         }           // Отрисовываем окно информации         if (Coupons[number] != -1) // Если у "Человека в очереди" с номером выбранной ячеки номерок не равен -1 Отрисовывем окно информации         {             GUI.Box(new Rect(300, 635, 650, 175), "", DescriptionStyle);    // Рисуем окно (Коробка) информаци о предмете              // Рисуем этикетку с именем предмета со склада равный номерку "Человека в очереди" а "Человек" равен номеру выбранной ячейки             GUI.Label(new Rect(300, 635, 210, 25), NamesObjects[Coupons[number]], NameDescrObjStyle);              // Если в массиве descriptionObject (Номер элемента из переменной Coupons[number]) описание не равно пустому полю             if (DescriptionsObjects[Coupons[number]] != "")                 GUI.Label(new Rect(650, 660, 300, 150), DescriptionsObjects[Coupons[number]]);// То рисуем текстовое поле с описанием.             else                         // Если же описание равно пустому тексту (Тоесть отсутствует)                 GUI.Label(new Rect(650, 660, 300, 150), "Описание отсутствует"); // Рисуем текстовое поле и пишем "Описание отсутствует"              if (TexturesObjects[Coupons[number]] != null) // Если на складе инвентаря( Слот склада равен выбранной ячейки) есть текстура                 GUI.DrawTexture(new Rect(301, 661, 148, 148), TexturesObjects[Coupons[number]]); // Рисуем текстуру из ячейки склада         }         return number;     }       // Объявляем метод DrawCategory он занимаеться отрисовкой инвентаря в вызванной категории     int DrawCategory(int number, Texture[] textures, Type type)     {         number = GUI.SelectionGrid(new Rect(935, 115, 320, 512), number, textures, 5, CellStyle); // рисуем слоты инвентаря          int calCup; // "calculatedCupon" Купон в итерации[i] который соответствует ячейке в итерации[i]          // Рисуем "Коробки" с цифрами или состоянием предметов для слотов инвентаря         for (int i = 0; textures[i] != null; i++) // Продолжаем цикл до тех пор пока не кончаться текстуры в опрашиваемой категории         {             calCup = CalculateCupon(i, type); // Каждую итерацию находим купона соответствующего выбранной ячейке в выбранной категории                                               // Если значение количествава предметов в ячейке на "Cкладе" не равно нулю             if (StackValue[Coupons[calCup]] > 1)                 GUI.Box(UpperCells[i], "" + StackValue[Coupons[calCup]], UpperCellStyle); // То отрисовываем количество предметов в ячейке                                                                                           // Если объект в ячейке на "Складе" разрушаемый а его значение целостности больше 0% и менее 100%             if (Destroyable[Coupons[calCup]] == true & State[Coupons[calCup]] > 0 & State[Coupons[calCup]] < 100)             {                 // То мы отрисовываем полоску состояния предмета для этой ячейки                 colors[0] = Color.Lerp(Color.red, Color.green, State[Coupons[calCup]] / 100); // сначала определяем цвет                 line.SetPixels(colors); // присваиваем этот цвет полоске которую мы отрисуем в этом цикле, в этой ячейке                 line.Apply();           // Сохраняем изменение цвета текстуры полоски                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50, 3), Backline);                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50 * State[Coupons[calCup]] / 100, 3), line);             }              if (i == AS - 1) break; // Если номер цикла стал равен количеству ячеек -1 то прекращаем цикл во избежании ошибки         }          int coup;   // Номер купона который соответствует номеру выбранной ячейки в инвентаре         coup = CalculateCupon(number, type); // Вызываем метод вычисляющий номер купона к которому мы будем обращаться за номером ячейки "Cклада"          // Отрисовываем окно информации         if (coup != -1) // Если coup не равен -1 Отрисовываем окно c информацией об объекте         {             GUI.Box(new Rect(300, 635, 650, 175), "", DescriptionStyle);    // Рисуем окно (Коробка) информаци о предмете              // Рисуем этикетку с именем предмета со склада равный номерку "Человека в очереди" а "Человек" равен номеру выбранной ячейки             GUI.Label(new Rect(300, 635, 210, 25), NamesObjects[Coupons[coup]], NameDescrObjStyle);              // Если в массиве descriptionObject (Номер элемента из переменной coupon) описание не равно пустому имени             if (DescriptionsObjects[Coupons[coup]] != "")                 GUI.Label(new Rect(650, 660, 300, 150), DescriptionsObjects[Coupons[coup]]);// То рисуем текстовое поле с описанием.             else                         // Если же описание равно пустому тексту (Тоесть отсутствует)                 GUI.Label(new Rect(650, 660, 300, 150), "Описание отсутствует"); // Рисуем текстовое поле и пишем "Описание отсутствует"              if (TexturesObjects[Coupons[coup]] != null) // Если на складе инвентаря( Слот склада равен переменной coupon) есть текстура                 GUI.DrawTexture(new Rect(301, 661, 148, 148), TexturesObjects[Coupons[coup]]); // Рисуем текстуру из ячейки склада         }         return number;     }       // Этот метод вычисляет купона который содержит текстуру в категории мы послыаем сюда тип категории и номер выбраннйо ячейки в ответ получаем     // номер "Человека в очереди" который содержит всю информацию о выбранном объекте в категории     int CalculateCupon(int SelectedSlot, Type type)     {         int numberCat = -1; // Номер объекта совпавший с типом категории         int coupon; // Вычисляем номер купона который в итоге соответствует номеру выбранной ячейки в инвентаре          for (coupon = 0; true; coupon++) // Цикл будет работать пока не прервёться оператором break внутри цикла при обпределённом условии         {             if (Coupons[coupon] == -1) // Если у обрабатываемого Человека в очереди талон равен -1             {                 coupon = -1;    // Мы ставим номер купона как -1                 break;          // Прерываем цикл             }             else if (TypesObjects[Coupons[coupon]] == type) // Если у "Человека в очереди" на "Складе" тип объекта равен параметру метода "type"             {                 numberCat++; // Прибавляем к numberCat +1 чтобы в конце концов найти объект на "Cкладе" Который мы выбрали в "Категории"                 if (SelectedSlot == numberCat)  // Если SelectedSlot равен numberCat                     break; // Прерываем цикл чтобы не позволить прибавиться переменной coupon ещё раз             }         }         return coupon; // Как результат этого метода возвращаем номер купона который связывает выбранную ячейку и объект на складе     }       // Этот метод вызываеться если вещи в инвентаре были изменены и категория "Всё" Была открыта. Для каждой категории текстур нужен свой массив      // так как метод SelectionGrid требует массив он не может работать с ячейками по одной. Вот мы и заполняем сдесь массив инвентаря "Всё"      void FillCategoryAll()     {         int number;          for (number = 0; Coupons[number] != -1; number++) // Продолжаем цикл до тех пор пока у "Человека в очереди" номер не равен -1         {             // Каждый цикл заполняем ячейки инвентаря, каждый цикл опрашивая по одному "Человеку в очереди" на номер его багажа на складе             AllTextures[number] = TexturesObjects[Coupons[number]];             if (number == AS - 1) // Если номер ячейки равен конечной ячейке             {                 number++; // Прибавляем к ячейке +1 чтобы в следующем цикле не опрашивать несуществующую ячейку                 break;             }         }          // Этот цикл заставит все последующие ячейки очиститься         for (int i = number; i < AS; i++)         {             AllTextures[i] = null;         }     }      // Тоже самое что и "FillCategoryAll" только тут мы заполняем выбранную категорию кроме категории всё     void FillCategory(Texture[] Textures, Type type)     {         int Category = 0; // Эта переменная отмечает номер заполняемой ячейки в заполняемой категории         int number;         // Продолжаем цикл пока не наткнёмся на "Человека в очереди" у которого номер в талоне равен -1         for (number = 0; Coupons[number] != -1; number++)         {             if (TypesObjects[Coupons[number]] == type) // Если у "Человека в очереди" на "Складе" тип объекта равен параметру этого метода "type"             {                 // То загружаем текстуру из той ячейки склада в ячейку "той категории с которой мы сейчас работаем" с номером Category                 Textures[Category] = TexturesObjects[Coupons[number]];                 Category++; // И так как одну ячейку в категории мы заполнили прибавляем к WeaponCategory +1 чтобы потом заполнить следующую             }             if (number == AS - 1)// Если номер ячейки равен конечной ячейке             {                 number++; // Прибавляем к ячейке +1 чтобы в следующем цикле не опрашивать несуществующую ячейку                 break; // Прерываем текущий цикл             }         }          // Этот цикл заставит все последующие ячейки очиститься         for (int i = number; i < AS; i++)         {             Textures[i] = null;         }     }       // Этот метод вызываеться если вещи в инвентаре были изменены и категория "Всё" Была открыта. Он заполняет категорию инвентаря "Всё"      void UseObject()     {      }       // Этот метод вызываеться когда нам нужно выбросить выбранный объект     void DropObject()     {         switch (ToolBarInt)         {             case 0:                 if (Coupons[AllNumber] != -1) // Если у "Человека в очереди" "Талон" не имеет номер -1                     DropFromCategory(AllNumber);  // тогда мы вызываем метод...                 break;             case 1:                 int couponOne = CalculateCupon(WeaponNumber, Type.Weapon); // Вызываем метод "Вычислить купона"                  if (couponOne != -1) DropFromCategory(couponOne); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFromCategory                 break;             case 2:                 int couponTwo = CalculateCupon(ArmorNumber, Type.Armor); // Вызываем метод "Вычислить купона"                 if (couponTwo != -1) DropFromCategory(couponTwo); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFromCategory                 break;             case 3:                 int couponThree = CalculateCupon(FoodNumer, Type.Food); // Вызываем метод "Вычислить купона"                 if (couponThree != -1) DropFromCategory(couponThree); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFromCat..                 break;             case 4:                 int couponFourth = CalculateCupon(MagicNumer, Type.Magic); // Вызываем метод "Вычислить купона"                 if (couponFourth != -1) DropFromCategory(couponFourth); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFrom..                 break;             case 5:                 int couponFifth = CalculateCupon(ConstructionNumber, Type.Construction); // Вызываем метод "Вычислить купона"                 if (couponFifth != -1) DropFromCategory(couponFifth); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFrom..                 break;             case 6:                 int couponSixth = CalculateCupon(OtherNumber, Type.Other); // Вызываем метод "Вычислить купона"                 if (couponSixth != -1) DropFromCategory(couponSixth); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFrom..                 break;         }         EngagedSlots--;     }      // !!!! Нужно сделать чтобы при подбирании нестакуемого объекта ему тоже плюсовалось +1 объект. Чтобы когда мы будем его выбрасывать      // Мы смогли проверить по этой цифре ведь стакуемый или нет переменная только в самом объекте тут такой нет. Поэтому мы проверяем по     // количеству объектов в ячейке. таким образом легче объеденить методы.. Мы спрашиваем если в ячейке больше одного то мы просто убавляем     // один так как создать объект вызываеться раньше то его вызывать уже ненадо, иначе если у нас в ячейке один то мы вызываем стирание со склада     // всех парметров а также минусуем место что в ячейке у нас 0 обектов.     // Вызываем из метода DropObject если нам нужно выбросить объект из любой категории за исключением категории "Всё"     void DropFromCategory(int couponNumber)     {         CreateObject(couponNumber);                     // Вызываем функцию создать объект          switch (TypesObjects[Coupons[couponNumber]])    // Получаем тип объекта и говорим что категория типа этого объекта была изменена         {             case Type.Weapon: WeapChanged = true; break;        // Если тип "Оружие" то изменяем WeapChanged на "правда"             case Type.Armor: ArmorChanged = true; break;        // Если тип "Броня" то изменяем ArmorChanged на "правда"             case Type.Food: FoodChanged = true; break;          // Если тип "Еда" то изменяем FoodChanged на "правда"             case Type.Magic: MagicChanged = true; break;        // Если тип "Магия" то изменяем MagicChanged на "правда"             case Type.Construction: ConsChanged = true; break;  // Если тип "Строительство" то изменяем ConsChanged на "правда"             case Type.Other: OtherChanged = true; break;        // Если тип "Разное" то изменяем OtherChanged на "правда"         }          if (StackValue[Coupons[couponNumber]] > 1)  // Если в ячейке выбранного слота больше одного объекта             StackValue[Coupons[couponNumber]]--;    // Отнимаем от значения количества предметов в ячейке 1          else if (StackValue[Coupons[couponNumber]] == 1)    // Если же в ячейке всего один объект         {             StackValue[Coupons[couponNumber]]--;                    // Отнимаем от значения количества предметов в ячейке 1             NamesObjects[Coupons[couponNumber]] = "";               // Обнуляем имя выбрасываемого объекта на "Складе"              DescriptionsObjects[Coupons[couponNumber]] = "";        // Обнуляем описание выбрасываемого объекта на "Складе"              TexturesObjects[Coupons[couponNumber]] = null;          // Обнуляемм текстуру выбрасываемого объекта на "Складе"             TypesObjects[Coupons[couponNumber]] = Type.undefined;   // Выставляем тип объекта на "Складе" для приличия на значение по умолчанию             QueueObject[Coupons[couponNumber]] = 0;                 // Выставляем приоритет в своей категории этого слота на "Складе" на ноль             PathsObjects[Coupons[couponNumber]] = "";           // Стираем путь к префабу выбрасываемого объекта на "Складе"             Coupons.RemoveAt(couponNumber);                     // Удаляем из очереди вычесленного купона             Coupons.Add(-1);                                    // Вставляем в конец очереди "Нового человека" с номером -1 и у нас снова 40 чел.             InvChanged = true;                                  // И говорим что категория "Всё" была изменена         }     }       // Этот метод создаёт объект при выбрасывании. Вызываеться из метода DropObject     // Передаём сюда номер купона у которого мы спрашиваем номер склада откуда возьмём все данные об объекте     void CreateObject(int CuponNumber)     {         GameObject drop = Instantiate(UnityEditor.AssetDatabase.LoadAssetAtPath(PathsObjects[Coupons[CuponNumber]], typeof(GameObject))) as GameObject;         drop.transform.position = CharacterBasis.transform.position + CharacterBasis.transform.forward + CharacterBasis.transform.up;     } } 