// Этот скрипт вешаеться на CharecterBasis и выполняет роль отрисовки инвентаря игрока using UnityEngine; using System.Collections.Generic; using UnityEngine.UI;  //int ListSlot = 0;				// Номер слота в списке //List<string> NamesAllObject;	// Имена всех объектов //List<string> DescrAllObject;	// Описания всех объектов //List<Texture> TextureAllObj;	// Текстуры всех объектов  //!!!!!!! Когда сделаю выкидывание объектов нужно сделать чтобы переменная EngagedSlots в этом скрипте уменьшалась чтобы правильно сигнали- // зировать когда нужно высвечивать окошко что инвентарь полон а когда не нужно  public class Inventory : MonoBehaviour {     public Sprite[] Images;                 // Changing button images     public GameObject[] panels;             // Array of UI Elements     public GameObject InventoryPanel;       // The main window of the inventory is stored here.     public Texture2D line, Backline;        // Текстура полоски состояния предметов в инвентаре и фоновая полоска     public Color[] colors = new Color[1];   // Массив цветов обязательный для этой линии состоящий всего из одного цвета     Color[] colorsback = new Color[1];      // Массив цветов обязательный для этой линии состоящий всего из одного цвета     const int AS = 40;                      // Amount SlotsМаксимальное количество слотов в инвентаре     public ObjectRegisrator OR;             // Сдесь лежит скрипт ObjectRegistrator     public PlayerController PC;             // Сдесь лежит скрипт PlayerController     public PlayerCamera PlCam;              // Сдесь лежит скрипт PlayerCamera     public bool InventoryOn = false;        // включен ли инвентарь, true говорит о том что включен     public int EngagedSlots = 0;            // Количество занятых слотов нужно чтобы не дать ложить предметы если макс кол достигнуто     public bool InvChanged = false;         // "InventoryChanged" Было ли изменено содержимое инвентаря     public bool WeapChanged = false;        // "WeaponChenged" Была ли изменена категория "Оружие"     public bool ArmorChanged = false;       // Была ли изменена категория "Защита"     public bool FoodChanged = false;        // Была ли изменена категория "Еда"     public bool MagicChanged = false;       // Была ли изменена категория "Магия"     public bool ConsChanged = false;        // "ConstructionChanged" Была ли изменена категория с "Строительство"     public bool OtherChanged = false;       // Была ли изменена категория с "Разное"     public Transform CharacterBasis;        // Сдесь лежит трансформация пустышки игрока CharacterBasis     public GUIStyle ToolBarStyle;           // Стиль кнопок для категорий предметов     public GUIStyle NameDescrObjStyle;      // Стиль имени объекта в описании предмета     public GUIStyle DescriptionStyle;       // Стиль окна описания предметов     public GUIStyle CellStyle;              // Стиль ячеек в инвентаре     public GUIStyle UpperCellStyle;         // Стиль для текста в ячейках инвентаря отображающего количество объектов или их состояние     public Rect[] UpperCells = new Rect[AS];// Это массив с координатами ячеек инвентаря с информацией которые лягут поверх обычных ячеек       // Категории - Всё, Оружие, Защита, Еда и зелья, Магия, Строительство, Прочее.. Инструменты(Tool) храняться в прочем.     public Texture[] CategoriesImage;       // Изображения для категорий     int ActiveCategory = 0;                 // Номер категори который сейчас выбран     public bool InventoryDrawn = false;     // The variable indicates whether we have drawn inventory      // "Талоны" Я назвал этот список так потому что номера в этом списке похожи на людей в очереди с талонами У каждого человека есть "талон"     // Номер с описаниями именами и прочем Какбы талон на получение контенера с вещами на складе, а номер этого человека в очереди соответствует     // номер текстуры в категории всё     public List<int> Coupons;                                   // Объявляем список "Талоны" //-----------------------------------------------------------------------------------------------------------------------------------------------     public StoreObjectData[] ObjectsInStore = new StoreObjectData[40];    // Объекты на складе (Заменяет разом все переменные снизу в этой категории)  //    public string[] NamesObjects = new string[AS];              // Имена всех объектов на "Cкладе" информации //    public string[] DescriptionsObjects = new string[AS];       // Описание всех объектов на "Cкладе" информации //    public Sprite[] TexturesObjects = new Sprite[AS];           // Текстуры всех объектов на "Cкладе" //    public Type[] TypesObjects = new Type[AS];                  // Типы всех объектов на "Складе" //    public int[] QueueObject = new int[AS];                     // Номер объекта по которому он ставиться в очереди //    public string[] PathsObjects = new string[AS];              // Пути всех обектов на "Складе" //    public int[] StackValue = new int[AS];                      // В этом массиве храняться значения -(Сколько объектов в ячейке на "Складе") //    public bool[] Destroyable = new bool[AS];                   // Массив состояний объектов на "Складе" (Разрушаемый не разрушаемый) //    public float[] State = new float[AS];                       // Массив состояний насколько сломан объект на "Складе" (Новый или сломанный)                                                                 //-----------------------------------------------------------------------------------------------------------------------------------------------      public int ActiveСellNumber = 0;                            // Active cell number (На замену всем номерам будет один единый номер, категории переключаются номер остаётся)      public int AllNumber = 0;                                   // Номер выбраной ячейки в категории "Всё"     public Sprite[] AllTextures = new Sprite[AS];               // Текстуры всех объектов в категории "Всё"      public int WeaponNumber = 0;                                // Номер выбраной ячейки в категории "Оружие"     public Sprite[] TexturesWeapon = new Sprite[AS];            // Текстуры всего оружия в категории "Оружие"      public int ArmorNumber = 0;                                 // Номер выбраной ячейки в категории "Броня"     public Sprite[] TexturesArmor = new Sprite[AS];             // Текстуры всей брони в категории "Броня"      public int FoodNumer = 0;                                   // Номер выбраной ячейки в категории "Еда"     public Sprite[] TexturesFood = new Sprite[AS];              // Текстуры всей еды в категории "Еда"      public int MagicNumer = 0;                                  // Номер выбраной ячейки в категории "Магия"     public Sprite[] TexturesMagic = new Sprite[AS];             // Текстуры всей магии в категории "Магия"      public int ConstructionNumber = 0;                          // Номер выбраной ячейки в категории "Конструкция"     public Sprite[] TexturesConstruction = new Sprite[AS];      // Текстуры всех конструкций в категории "Конструкция"      public int OtherNumber = 0;                                 // Номер выбраной ячейки в категории "Разное"     public Sprite[] TexturesOther = new Sprite[AS];             // Текстуры всего разного в категории "Разное"       void Start()     {         Cursor.visible = false;                     // Hide the cursor         Cursor.lockState = CursorLockMode.Locked;   // Lock cursor         CalculatePosition.GeneratePosition(935, 115, 64, 64, UpperCells, 5);         colorsback[0] = Color.black;        // Задаём переменной цвета colorsback чёрный цвет, это будет цвет фона для полоски здоровья предмета         line = new Texture2D(1, 1);         // Создаём текстуру полоски здоровья предмета и помещаем её в переменную line         Backline = new Texture2D(1, 1);     // Создаём текстуру фона полоски здоровья предмета и помещаем её в переменную Backline         Backline.SetPixels(colorsback);     // Заполняем текстуру фона полоски здоровья предмета чёрным         Backline.Apply();                   // Применяем изменения цвета фона     }       void Update()     {         if (Input.GetKeyDown(KeyCode.Tab) && InventoryPanel.activeSelf == true)       // If the inventory call button was pressed and the inventory was turned off         {             InventoryPanel.SetActive(false);            // Activate the inventory panel             panels[2].gameObject.SetActive(false);      // Turn off the object information panel             OR.enabled = true;                          // Включаем скрипт регестрации объектов             Cursor.visible = false;                     // Hide the cursor             Cursor.lockState = CursorLockMode.Locked;   // Lock cursor                      }         else if (Input.GetKeyDown(KeyCode.Tab) && InventoryPanel.activeSelf == false) // Otherwise, if the call button for the inventory was pressed and the inventory was turned on         {             InventoryPanel.SetActive(true);             // Deactivate the inventory panel             OnOffInformationWindow();                   // Determine whether to enable the object information window             OR.enabled = false;                         // То мы выключаем скрипт регестрирования объектов             Cursor.visible = true;                      // Make the cursor visible.             Cursor.lockState = CursorLockMode.None;     // Unlock the cursor         }          if (ActiveCategory == 0 && !InventoryDrawn)         {             UpdateCategoryAll(ActiveСellNumber, AllTextures);   // We update the rendering of items in the inventory             InventoryDrawn = true;                              // We indicate that the drawing was done         }     }      /*     // Отрисовываем общий инвентарь если он включен     void OnGUI()     {                  if (InventoryOn)                        // Если инвентарь включен         {             GUI.Box(new Rect(870, 60, 400, 580), "");           // Рисуем коробку размером с область инвентаря             GUI.Box(new Rect(930, 110, 330, 522), "");          // Создаём коробку в виде заднего фона             ActiveCategory = GUI.Toolbar(new Rect(930, 70, 330, 40), ActiveCategory, CategoriesImage, ToolBarStyle);    // Рисуем категории предметов              if (GUI.Button(new Rect(970, 640, 150, 30), "Use")) // Рисуем кнопку "Использовать объект" и если она нажата...                 UseObject(); // Вызываем метод использовать объект              if (GUI.Button(new Rect(1120, 640, 150, 30), "Drop")) // Рисуем кнопку "Бросить объект" и если она нажата...                 DropObject(); // Вызываем метод "Бросить объект"               switch (ActiveCategory)             {                 case 0:                     if (InvChanged) // Если Менялось содержимое инвентаря                         FillCategoryAll();  // То вызываем метод FillCategoryAll                     AllNumber = UpdateCategoryAll(AllNumber, AllTextures); // Вызываем метод DrawInventory (Отрисовка категории "Всё")                     InvChanged = false;  // И говорим что инвентарь больше не изменялься                     break;                 case 1:                     if (WeapChanged)    // Если содержимое категории "Оружие" было изменено                         FillCategory(TexturesWeapon, Type.Weapon);  // Вызываем метод FillCategory                     WeaponNumber = DrawCategory(WeaponNumber, TexturesWeapon, Type.Weapon); // Вызываем метод DrawCategoty (Отрисовка категории)                     WeapChanged = false; // И говорим что категория "Оружие" больше не изменялась                     break;                 case 2:                     if (ArmorChanged)   // Если содержимое категории "Броня" было изменено                         FillCategory(TexturesArmor, Type.Armor);  // Вызываем метод FillCategory                     ArmorNumber = DrawCategory(ArmorNumber, TexturesArmor, Type.Armor); // Вызываем метод DrawCategoty (Отрисовка категории)                     ArmorChanged = false; // И говорим что категория "Броня" больше не изменялась                     break;                 case 3:                     if (FoodChanged) // Если содержимое категории "Еда" было изменено                         FillCategory(TexturesFood, Type.Food);  // Вызываем метод FillCategory                     FoodNumer = DrawCategory(FoodNumer, TexturesFood, Type.Food); // Вызываем метод DrawCategoty (Отрисовка категории)                     FoodChanged = false; // И говорим что категория "Еда" больше не изменялась                     break;                 case 4:                     if (MagicChanged) // Если содержимое категории "Магия" было изменено                         FillCategory(TexturesMagic, Type.Magic);  // Вызываем метод FillCategory                     MagicNumer = DrawCategory(MagicNumer, TexturesMagic, Type.Magic); // Вызываем метод DrawCategoty (Отрисовка категории)                     MagicChanged = false; // И говорим что категория "Магия" больше не изменялась                     break;                 case 5:                     if (ConsChanged) // Если категория "Строительство" была изменена                         FillCategory(TexturesConstruction, Type.Construction);  // Вызываем метод FillCategory                     ConstructionNumber = DrawCategory(ConstructionNumber, TexturesConstruction, Type.Construction); // Вызываем метод DrawCategoty                     ConsChanged = false; // И говорим что категория "ConstructionChanged" больше не изменялась                     break;                 case 6:                     if (OtherChanged) // Если категория "Разное" была изменена                         FillCategory(TexturesOther, Type.Other);  // Вызываем метод FillCategory                     OtherNumber = DrawCategory(OtherNumber, TexturesOther, Type.Other); // Вызываем метод DrawCategoty (Отрисовка категории)                     OtherChanged = false; // И говорим что категория "OtherChanged" больше не изменялась                     break;             }         }     }     */      /*      // Объявляем метод DrawInventory он занимаеться отрисовкой инвентаря в категории "Всё"     int UpdateCategoryAll(int number, Texture[] textures)     {         number = GUI.SelectionGrid(new Rect(935, 115, 320, 512), number, textures, 5, CellStyle);               // Рисуем слоты инвентаря                                                                                                                 // Рисуем "Коробки" с цифрами или состоянием предметов для слотов инвентаря         for (int i = 0; Coupons[i] != -1; i++) // Продолжаем цикл до тех пор пока номер купона не равен -1         {             if (StackValue[Coupons[i]] > 1) // Если значение количества предметов в ячейке на складе больше одного                 GUI.Box(UpperCells[i], "" + StackValue[Coupons[i]], UpperCellStyle); // То отрисовываем количество предметов в ячейке                                                                                      // Если объект в ячейке на "Складе" разрушаемый а его значение целостности больше 0% и менее 100%             if (Destroyable[Coupons[i]] == true & State[Coupons[i]] > 0 & State[Coupons[i]] < 100)             {   // То мы отрисовываем полоску состояния предмета для этой ячейки                 colors[0] = Color.Lerp(Color.red, Color.green, State[Coupons[i]] / 100); // сначала определяем цвет                 line.SetPixels(colors); // присваиваем этот цвет полоске которую мы отрисуем в этом цикле, в этой ячейке                 line.Apply();           // Сохраняем изменение цвета текстуры полоски                                         // Отрисовываем жизни предмета и задниф фон жизней                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50, 3), Backline);                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50 * State[Coupons[i]] / 100, 3), line);                 if (i == AS - 1) break; // Если номер цикла стал равен количеству ячеек -1 то прекращаем цикл             }         }           // Отрисовываем окно информации         if (Coupons[number] != -1) // Если у "Человека в очереди" с номером выбранной ячеки номерок не равен -1 Отрисовывем окно информации         {             GUI.Box(new Rect(300, 635, 650, 175), "", DescriptionStyle);    // Рисуем окно (Коробка) информаци о предмете              // Рисуем этикетку с именем предмета со склада равный номерку "Человека в очереди" а "Человек" равен номеру выбранной ячейки             GUI.Label(new Rect(300, 635, 210, 25), NamesObjects[Coupons[number]], NameDescrObjStyle);              // Если в массиве descriptionObject (Номер элемента из переменной Coupons[number]) описание не равно пустому полю             if (DescriptionsObjects[Coupons[number]] != "")                 GUI.Label(new Rect(650, 660, 300, 150), DescriptionsObjects[Coupons[number]]);// То рисуем текстовое поле с описанием.             else                         // Если же описание равно пустому тексту (Тоесть отсутствует)                 GUI.Label(new Rect(650, 660, 300, 150), "Описание отсутствует"); // Рисуем текстовое поле и пишем "Описание отсутствует"              if (TexturesObjects[Coupons[number]] != null) // Если на складе инвентаря( Слот склада равен выбранной ячейки) есть текстура                 GUI.DrawTexture(new Rect(301, 661, 148, 148), TexturesObjects[Coupons[number]]); // Рисуем текстуру из ячейки склада         }         return number;     }      */      void ChangeActiveCellNomber(int NewNomber)   // This method changes the selected inventory cell.     {         panels[1].transform.GetChild(ActiveСellNumber).GetComponent<Image>().sprite = Images[2];    // Assign the previous cell a standard texture         panels[1].transform.GetChild(NewNomber).GetComponent<Image>().sprite = Images[3];           // Assign the appropriate texture to the selected cell.         ActiveСellNumber = NewNomber;                                                               // Change the number of the active cell         UpdateCategoryAll(ActiveСellNumber, AllTextures);                                           // We update the rendering of items in the inventory         OnOffInformationWindow();                                                                   // We call the method deciding whether to enable the information window     }      int UpdateCategoryAll(int number, Sprite[] textures)    // This method updates the information for the "all" category.     {         for (int i = 0; Coupons[i] != -1; i++)  // Продолжаем цикл до тех пор пока номер купона не равен -1         {             panels[1].transform.GetChild(Coupons[i]).transform.GetChild(0).GetComponent<Image>().enabled = true;                                            // Turn on the next cell texture in the loop             panels[1].transform.GetChild(Coupons[i]).transform.GetChild(0).GetComponent<Image>().sprite = ObjectsInStore[Coupons[i]].ObjectTexture;         // Assign the next cell in the loop its corresponding texture              if (ObjectsInStore[Coupons[i]].StackCount > 1)     // Если значение количества предметов в ячейке на складе больше одного             {                 panels[1].transform.GetChild(Coupons[i]).transform.GetChild(1).GetComponent<Text>().enabled = true;                                         // Enable the text of the number of items                 panels[1].transform.GetChild(Coupons[i]).transform.GetChild(1).GetComponent<Text>().text = ObjectsInStore[Coupons[i]].StackCount.ToString();// We indicate in the text the number of items             }              // Если объект в ячейке на "Складе" разрушаемый а его значение целостности менее 100%             if (ObjectsInStore[Coupons[i]].DestroyableObject == true &  ObjectsInStore[Coupons[i]].StateObject < 100)             {   // То мы отрисовываем полоску состояния предмета для этой ячейки                 panels[1].transform.GetChild(Coupons[i]).transform.GetChild(2).GetComponent<Image>().enabled = true;    // Activate the item status bar back image                 panels[1].transform.GetChild(Coupons[i]).transform.GetChild(3).GetComponent<Image>().enabled = true;    // Activate the item status bar image                 panels[1].transform.GetChild(Coupons[i]).transform.GetChild(3).GetComponent<Image>().color                     = Color.Lerp(Color.red, Color.green, ObjectsInStore[Coupons[i]].StateObject / 100);                 // Determine the color of the strip of item status                  // 0.92 is one division of a whole line 92 units wide                 // Set the size of the item status line                 panels[1].transform.GetChild(Coupons[i]).transform.GetChild(3).GetComponent<RectTransform>().sizeDelta = new Vector2(0.92f * ObjectsInStore[Coupons[i]].StateObject, 10);                  if (i == AS - 1) break; // Если номер цикла стал равен количеству ячеек -1 то прекращаем цикл             }         }          // Updating the information window for the selected cell of the "all" category         if (Coupons[number] != -1) // Если у "Человека в очереди" с номером выбранной ячеки номерок не равен -1 Отрисовывем окно информации         {             panels[2].transform.GetChild(0).GetComponent<Text>().text = ObjectsInStore[Coupons[number]].ObjectName;                      // Update the object name in the object information window               if (ObjectsInStore[Coupons[number]].Description != "")                                                              // If the object has a description                 panels[2].transform.GetChild(1).GetChild(0).GetComponent<Text>().text = ObjectsInStore[Coupons[number]].Description;   // We update the description of the object in the information window             else                                                                                                                // If the object has no description                 panels[2].transform.GetChild(1).GetChild(0).GetComponent<Text>().text = "Описание отсутствует";                 // We write that the description is missing              if (ObjectsInStore[Coupons[number]].ObjectTexture != null) // Если на складе инвентаря( Слот склада равен выбранной ячейки) есть текстура                 panels[2].transform.GetChild(2).GetComponent<Image>().sprite = ObjectsInStore[Coupons[number]].ObjectTexture; // Draw a texture from a warehouse cell               //            if (TexturesObjects[Coupons[number]] != null) // Если на складе инвентаря( Слот склада равен выбранной ячейки) есть текстура             //                GUI.DrawTexture(new Rect(301, 661, 148, 148), TexturesObjects[Coupons[number]]); // Draw a texture from a warehouse cell         }         else         {          }          return number;     }       void OnOffInformationWindow()   // This method decides whether to enable or disable the info window.     {         if (Coupons[ActiveСellNumber] == -1)        // Если у "Человека в очереди" с номером выбранной ячеки номер равен -1             panels[2].gameObject.SetActive(false);  // То выключаем окно информации         else                                        // Иначе             panels[2].gameObject.SetActive(true);  // Отрисовывем окно информации     }      // Объявляем метод DrawCategory он занимаеться отрисовкой инвентаря в вызванной категории     int DrawCategory(int number, Sprite[] textures, Type type)     { //        number = GUI.SelectionGrid(new Rect(935, 115, 320, 512), number, textures, 5, CellStyle); // рисуем слоты инвентаря          int calCup; // "calculatedCupon" Купон в итерации[i] который соответствует ячейке в итерации[i]          // Рисуем "Коробки" с цифрами или состоянием предметов для слотов инвентаря         for (int i = 0; textures[i] != null; i++) // Продолжаем цикл до тех пор пока не кончаться текстуры в опрашиваемой категории         {             calCup = CalculateCupon(i, type); // Каждую итерацию находим купона соответствующего выбранной ячейке в выбранной категории                          if (ObjectsInStore[Coupons[calCup]].StackCount > 1) // Если значение количествава предметов в ячейке на "Cкладе" не равно нулю                 GUI.Box(UpperCells[i], "" + ObjectsInStore[Coupons[calCup]].StackCount, UpperCellStyle); // То отрисовываем количество предметов в ячейке              // Если объект в ячейке на "Складе" разрушаемый а его значение целостности менее 100%             if (ObjectsInStore[Coupons[calCup]].DestroyableObject == true & ObjectsInStore[Coupons[calCup]].StateObject < 100)             {                 // То мы отрисовываем полоску состояния предмета для этой ячейки                 colors[0] = Color.Lerp(Color.red, Color.green, ObjectsInStore[Coupons[calCup]].StateObject / 100); // сначала определяем цвет                 line.SetPixels(colors); // присваиваем этот цвет полоске которую мы отрисуем в этом цикле, в этой ячейке                 line.Apply();           // Сохраняем изменение цвета текстуры полоски                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50, 3), Backline);                 GUI.DrawTexture(new Rect(UpperCells[i].position.x + 7, UpperCells[i].position.y + 58, 50 * ObjectsInStore[Coupons[calCup]].StateObject / 100, 3), line);             }              if (i == AS - 1) break; // Если номер цикла стал равен количеству ячеек -1 то прекращаем цикл во избежании ошибки         }          int coup;   // Номер купона который соответствует номеру выбранной ячейки в инвентаре         coup = CalculateCupon(number, type); // Вызываем метод вычисляющий номер купона к которому мы будем обращаться за номером ячейки "Cклада"          // Отрисовываем окно информации         if (coup != -1) // Если coup не равен -1 Отрисовываем окно c информацией об объекте         {             GUI.Box(new Rect(300, 635, 650, 175), "", DescriptionStyle);    // Рисуем окно (Коробка) информаци о предмете              // Рисуем этикетку с именем предмета со склада равный номерку "Человека в очереди" а "Человек" равен номеру выбранной ячейки             GUI.Label(new Rect(300, 635, 210, 25), ObjectsInStore[Coupons[coup]].ObjectName, NameDescrObjStyle);              // Если в массиве descriptionObject (Номер элемента из переменной coupon) описание не равно пустому имени              if (ObjectsInStore[Coupons[coup]].Description != "")                 GUI.Label(new Rect(650, 660, 300, 150),ObjectsInStore[Coupons[coup]].Description);// То рисуем текстовое поле с описанием.             else                         // Если же описание равно пустому тексту (Тоесть отсутствует)                 GUI.Label(new Rect(650, 660, 300, 150), "Описание отсутствует"); // Рисуем текстовое поле и пишем "Описание отсутствует"  //            if (TexturesObjects[Coupons[coup]] != null) // Если на складе инвентаря( Слот склада равен переменной coupon) есть текстура //                GUI.DrawTexture(new Rect(301, 661, 148, 148), TexturesObjects[Coupons[coup]]); // Рисуем текстуру из ячейки склада         }         return number;     }       // Этот метод вычисляет купона который содержит текстуру в категории мы послыаем сюда тип категории и номер выбраннйо ячейки в ответ получаем     // номер "Человека в очереди" который содержит всю информацию о выбранном объекте в категории     int CalculateCupon(int SelectedSlot, Type type)     {         int numberCat = -1; // Номер объекта совпавший с типом категории         int coupon; // Вычисляем номер купона который в итоге соответствует номеру выбранной ячейки в инвентаре          for (coupon = 0; true; coupon++) // Цикл будет работать пока не прервёться оператором break внутри цикла при обпределённом условии         {             if (Coupons[coupon] == -1) // Если у обрабатываемого Человека в очереди талон равен -1             {                 coupon = -1;    // Мы ставим номер купона как -1                 break;          // Прерываем цикл             }              else if (ObjectsInStore[Coupons[coupon]].ObjectType == type) // Если у "Человека в очереди" на "Складе" тип объекта равен параметру метода "type"             {                 numberCat++; // Прибавляем к numberCat +1 чтобы в конце концов найти объект на "Cкладе" Который мы выбрали в "Категории"                 if (SelectedSlot == numberCat)  // Если SelectedSlot равен numberCat                     break; // Прерываем цикл чтобы не позволить прибавиться переменной coupon ещё раз             }         }         return coupon; // Как результат этого метода возвращаем номер купона который связывает выбранную ячейку и объект на складе     }       // Этот метод вызываеться если вещи в инвентаре были изменены и категория "Всё" Была открыта. Для каждой категории текстур нужен свой массив      // так как метод SelectionGrid требует массив он не может работать с ячейками по одной. Вот мы и заполняем сдесь массив инвентаря "Всё"      void FillCategoryAll()     {         int number;          for (number = 0; Coupons[number] != -1; number++) // Продолжаем цикл до тех пор пока у "Человека в очереди" номер не равен -1         {             // Каждый цикл заполняем ячейки инвентаря, каждый цикл опрашивая по одному "Человеку в очереди" на номер его багажа на складе             AllTextures[number] = ObjectsInStore[Coupons[number]].ObjectTexture;             if (number == AS - 1) // Если номер ячейки равен конечной ячейке             {                 number++; // Прибавляем к ячейке +1 чтобы в следующем цикле не опрашивать несуществующую ячейку                 break;             }         }          // Этот цикл заставит все последующие ячейки очиститься         for (int i = number; i < AS; i++)         {             AllTextures[i] = null;         }     }      // Тоже самое что и "FillCategoryAll" только тут мы заполняем выбранную категорию кроме категории всё     void FillCategory(Sprite[] Textures, Type type)     {         int Category = 0; // Эта переменная отмечает номер заполняемой ячейки в заполняемой категории         int number;         // Продолжаем цикл пока не наткнёмся на "Человека в очереди" у которого номер в талоне равен -1         for (number = 0; Coupons[number] != -1; number++)         {             if (ObjectsInStore[Coupons[number]].ObjectType == type) // Если у "Человека в очереди" на "Складе" тип объекта равен параметру этого метода "type"             {                 // То загружаем текстуру из той ячейки склада в ячейку "той категории с которой мы сейчас работаем" с номером Category                 Textures[Category] = ObjectsInStore[Coupons[number]].ObjectTexture;                 Category++; // И так как одну ячейку в категории мы заполнили прибавляем к WeaponCategory +1 чтобы потом заполнить следующую             }             if (number == AS - 1)// Если номер ячейки равен конечной ячейке             {                 number++; // Прибавляем к ячейке +1 чтобы в следующем цикле не опрашивать несуществующую ячейку                 break; // Прерываем текущий цикл             }         }          // Этот цикл заставит все последующие ячейки очиститься         for (int i = number; i < AS; i++)         {             Textures[i] = null;         }     }      public void ChageCategoryInventory(int CategoryNumber)  // This method switches categories in inventory     {         panels[0].transform.GetChild(ActiveCategory).GetComponent<Image>().sprite = Images[0];  // Change the texture to not selected from the previous selected button         panels[0].transform.GetChild(CategoryNumber).GetComponent<Image>().sprite = Images[1];  // At the selected button we put the texture of the selected button         ActiveCategory = CategoryNumber;                                                        // Specify the number of the newly selected category          switch (ActiveCategory)         {             case 0:                 if (InvChanged) // Если Менялось содержимое инвентаря                         FillCategoryAll();  // То вызываем метод FillCategoryAll                     AllNumber = UpdateCategoryAll(AllNumber, AllTextures); // Вызываем метод DrawInventory (Отрисовка категории "Всё")                     InvChanged = false;  // И говорим что инвентарь больше не изменялься                     break;             case 1:                 if (WeapChanged)    // Если содержимое категории "Оружие" было изменено                         FillCategory(TexturesWeapon, Type.Weapon);  // Вызываем метод FillCategory                     WeaponNumber = DrawCategory(WeaponNumber, TexturesWeapon, Type.Weapon); // Вызываем метод DrawCategoty (Отрисовка категории)                     WeapChanged = false; // И говорим что категория "Оружие" больше не изменялась                     break;             case 2:                 if (ArmorChanged)   // Если содержимое категории "Броня" было изменено                         FillCategory(TexturesArmor, Type.Armor);  // Вызываем метод FillCategory                     ArmorNumber = DrawCategory(ArmorNumber, TexturesArmor, Type.Armor); // Вызываем метод DrawCategoty (Отрисовка категории)                     ArmorChanged = false; // И говорим что категория "Броня" больше не изменялась                     break;             case 3:                 if (FoodChanged) // Если содержимое категории "Еда" было изменено                         FillCategory(TexturesFood, Type.Food);  // Вызываем метод FillCategory                     FoodNumer = DrawCategory(FoodNumer, TexturesFood, Type.Food); // Вызываем метод DrawCategoty (Отрисовка категории)                     FoodChanged = false; // И говорим что категория "Еда" больше не изменялась                     break;             case 4:                 if (MagicChanged) // Если содержимое категории "Магия" было изменено                         FillCategory(TexturesMagic, Type.Magic);  // Вызываем метод FillCategory                     MagicNumer = DrawCategory(MagicNumer, TexturesMagic, Type.Magic); // Вызываем метод DrawCategoty (Отрисовка категории)                     MagicChanged = false; // И говорим что категория "Магия" больше не изменялась                     break;             case 5:                 if (ConsChanged) // Если категория "Строительство" была изменена                         FillCategory(TexturesConstruction, Type.Construction);  // Вызываем метод FillCategory                     ConstructionNumber = DrawCategory(ConstructionNumber, TexturesConstruction, Type.Construction); // Вызываем метод DrawCategoty                     ConsChanged = false; // И говорим что категория "ConstructionChanged" больше не изменялась                     break;             case 6:                 if (OtherChanged) // Если категория "Разное" была изменена                         FillCategory(TexturesOther, Type.Other);  // Вызываем метод FillCategory                     OtherNumber = DrawCategory(OtherNumber, TexturesOther, Type.Other); // Вызываем метод DrawCategoty (Отрисовка категории)                     OtherChanged = false; // И говорим что категория "OtherChanged" больше не изменялась                     break;         }     }       // Этот метод вызываеться если вещи в инвентаре были изменены и категория "Всё" Была открыта. Он заполняет категорию инвентаря "Всё"      void UseObject()     {      }       // Этот метод вызываеться когда нам нужно выбросить выбранный объект     void DropObject()     {         switch (ActiveCategory)         {             case 0:                 if (Coupons[AllNumber] != -1) // Если у "Человека в очереди" "Талон" не имеет номер -1                     DropFromCategory(AllNumber);  // тогда мы вызываем метод...                 break;             case 1:                 int couponOne = CalculateCupon(WeaponNumber, Type.Weapon); // Вызываем метод "Вычислить купона"                  if (couponOne != -1) DropFromCategory(couponOne); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFromCategory                 break;             case 2:                 int couponTwo = CalculateCupon(ArmorNumber, Type.Armor); // Вызываем метод "Вычислить купона"                 if (couponTwo != -1) DropFromCategory(couponTwo); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFromCategory                 break;             case 3:                 int couponThree = CalculateCupon(FoodNumer, Type.Food); // Вызываем метод "Вычислить купона"                 if (couponThree != -1) DropFromCategory(couponThree); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFromCat..                 break;             case 4:                 int couponFourth = CalculateCupon(MagicNumer, Type.Magic); // Вызываем метод "Вычислить купона"                 if (couponFourth != -1) DropFromCategory(couponFourth); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFrom..                 break;             case 5:                 int couponFifth = CalculateCupon(ConstructionNumber, Type.Construction); // Вызываем метод "Вычислить купона"                 if (couponFifth != -1) DropFromCategory(couponFifth); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFrom..                 break;             case 6:                 int couponSixth = CalculateCupon(OtherNumber, Type.Other); // Вызываем метод "Вычислить купона"                 if (couponSixth != -1) DropFromCategory(couponSixth); // Если метод "Вычислить купона" вернул не -1 тогда вызываем метод DropFrom..                 break;         }         EngagedSlots--;     }      // !!!! Нужно сделать чтобы при подбирании нестакуемого объекта ему тоже плюсовалось +1 объект. Чтобы когда мы будем его выбрасывать      // Мы смогли проверить по этой цифре ведь стакуемый или нет переменная только в самом объекте тут такой нет. Поэтому мы проверяем по     // количеству объектов в ячейке. таким образом легче объеденить методы.. Мы спрашиваем если в ячейке больше одного то мы просто убавляем     // один так как создать объект вызываеться раньше то его вызывать уже ненадо, иначе если у нас в ячейке один то мы вызываем стирание со склада     // всех парметров а также минусуем место что в ячейке у нас 0 обектов.     // Вызываем из метода DropObject если нам нужно выбросить объект из любой категории за исключением категории "Всё"     void DropFromCategory(int couponNumber)     {         CreateObject(couponNumber);                     // Вызываем функцию создать объект          switch (ObjectsInStore[Coupons[couponNumber]].ObjectType)    // Получаем тип объекта и говорим что категория типа этого объекта была изменена         {             case Type.Weapon: WeapChanged = true; break;        // Если тип "Оружие" то изменяем WeapChanged на "правда"             case Type.Armor: ArmorChanged = true; break;        // Если тип "Броня" то изменяем ArmorChanged на "правда"             case Type.Food: FoodChanged = true; break;          // Если тип "Еда" то изменяем FoodChanged на "правда"             case Type.Magic: MagicChanged = true; break;        // Если тип "Магия" то изменяем MagicChanged на "правда"             case Type.Construction: ConsChanged = true; break;  // Если тип "Строительство" то изменяем ConsChanged на "правда"             case Type.Other: OtherChanged = true; break;        // Если тип "Разное" то изменяем OtherChanged на "правда"         }          if (ObjectsInStore[Coupons[couponNumber]].StackCount > 1)   // Если в ячейке выбранного слота больше одного объекта             ObjectsInStore[Coupons[couponNumber]].StackCount --;    // Отнимаем от значения количества предметов в ячейке 1          else if (ObjectsInStore[Coupons[couponNumber]].StackCount == 1)         // Если же в ячейке всего один объект         {             ObjectsInStore[Coupons[couponNumber]].StackCount--;                 // Отнимаем от значения количества предметов в ячейке 1             ObjectsInStore[Coupons[couponNumber]].ObjectName = "";              // Обнуляем имя выбрасываемого объекта на "Складе"              ObjectsInStore[Coupons[couponNumber]].Description = "";             // Обнуляем описание выбрасываемого объекта на "Складе"              ObjectsInStore[Coupons[couponNumber]].ObjectTexture = null;         // Обнуляемм текстуру выбрасываемого объекта на "Складе"             ObjectsInStore[Coupons[couponNumber]].ObjectType = Type.undefined;  // Выставляем тип объекта на "Складе" для приличия на значение по умолчанию             ObjectsInStore[Coupons[couponNumber]].Queue = 0;                    // Выставляем приоритет в своей категории этого слота на "Складе" на ноль             ObjectsInStore[Coupons[couponNumber]].Path = "";                    // Стираем путь к префабу выбрасываемого объекта на "Складе"             Coupons.RemoveAt(couponNumber);                                     // Удаляем из очереди вычесленного купона             Coupons.Add(-1);                                                    // Вставляем в конец очереди "Нового человека" с номером -1 и у нас снова 40 чел.             InvChanged = true;                                                  // И говорим что категория "Всё" была изменена         }     }       // Этот метод создаёт объект при выбрасывании. Вызываеться из метода DropObject     // Передаём сюда номер купона у которого мы спрашиваем номер склада откуда возьмём все данные об объекте     void CreateObject(int CuponNumber)     {         GameObject drop = Instantiate(UnityEditor.AssetDatabase.LoadAssetAtPath(ObjectsInStore[Coupons[CuponNumber]].Path, typeof(GameObject))) as GameObject;         drop.transform.position = CharacterBasis.transform.position + CharacterBasis.transform.forward + CharacterBasis.transform.up;     }      // -------------------------------------------------------------------------------------------- Button Metods ----------------------------------------------------------------------------------------      public void ChageCategoryInventoryButton(int CategoryNumber)    // Method called by buttons to switch inventory categories     {         ChageCategoryInventory(CategoryNumber);                     // We call the handler method     }       public void ChangeActiveCellNomberButton(int NewNomber)         // This method is called by clicking on one of the cell buttons.     {         ChangeActiveCellNomber(NewNomber);                          // We call the handler method     }       public void UseObjectButton()                                   // This method is called by the "Use Object" button.     {      }       public void DropObjectButton()                                  // This method is called by the "Drop Object" button.     {      }  } 